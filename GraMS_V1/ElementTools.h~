#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ShapeFunctions.h"
//#include "Constitutive.h"



/* Function for defining the element properties */
void Initialize_Element(Element * Elem,
			char * TypeElement,
			double ** GlobalNodsCoords,
			int * GlobalNodsId){
  
  if (strcmp(TypeElement,"Q4")==0){
    Elem->id = 0;
    Elem->NumberNodes = 4;
    Elem->NumberDOF = 2;
    Elem->X_g = GlobalNodsCoords;
    Elem->N_id = GlobalNodsId;
    Elem->n = Q4;
    Elem->dn = dQ4;
  }
}

void Initialize_GP(GaussPoint * GP,Vector * RefCoords){
  GP->x_EC = RefCoords;
}

void Get_Deformation_Gradient(GaussPoint * GP,Element * Elem,double ** F)
/*
  Get the deformation gradient of an element:

  F = x_{\alpha} \otimes grad(N_{\alpha})
  
  Inputs : 
  - X_e -> Coordenates of a GP in the reference element
  - Elem -> Structure with the properties of the element

  Output :
  - F -> Deformation gradient evaluated in the GP
*/
{

  double ** dn = (double **)Allocate_Matrix(Elem->NumberNodes,
					   Elem->NumberDOF,
					   sizeof(double));

  /* Get the values of the shape functions derivatives */
  dn = Elem->dn(GP->x_EC);

  for(int n = 0 ; n<Elem->NumberNodes ; n++){
    /* Loop over the nodes of the element */    
    for(int i = 0 ; i<Elem->NumberDOF ; i++){
      /* Loop over the degree of freedoms (Reference Element) */
      for(int j = 0 ; j<Elem->NumberDOF ; j++){
	/* Loop over the degree of freedoms (Element) */

	/* In this case we use isoparametric formulation, */
	if(n==0){/* Initialize and increase */
	  F[i][j] = 0;
	  F[i][j] += Elem->X_g[n][j]*dn[n][i];
	}
	else{ /* Increase */
	  F[i][j] += Elem->X_g[n][j]*dn[n][i];
	}
	
      }/* if j */
    }/* if i */
  }/* if n */

  /* Free memory */
  free(dn);
  
}


double ** Get_Lagrangian_CG_Tensor(GaussPoint * GP,Element * Elem)
  /* The Right Cauchy Green Deformation Tensor :
   C = F^{T} \cdot F */
{
  
  double ** C = (double **)Allocate_Matrix(Elem->NumberDOF,
					   Elem->NumberDOF,
					   sizeof(double));
  double ** F = (double **)Allocate_Matrix(Elem->NumberDOF,
					   Elem->NumberDOF,
					   sizeof(double));

  /* Calcule the deformation gradient F to get C */
  Get_Deformation_Gradient(GP,Elem,F);

  /* Get C */
  for(int i = 0; i<Elem->NumberDOF ; i++){
    for(int j = 0; j<Elem->NumberDOF; j++){
      C[i][j] = F[j][i] * F[i][j];
      /* C    =  F^{T}  *   F  */
    }
  }

  /* Free memory */
  free(F);
  
  return C;
}



double ** Get_Eulerian_CG_Tensor(GaussPoint * GP,Element * Elem)
  /* The Left Cauchy Green Deformation Tensor :
   B = F \cdot F^{T} */
{
  
  double ** B = (double **)Allocate_Matrix(Elem->NumberDOF,
					   Elem->NumberDOF,
					   sizeof(double));
  double ** F = (double **)Allocate_Matrix(Elem->NumberDOF,
					   Elem->NumberDOF,
					   sizeof(double));
  
  /* Calcule the deformation gradient to get B */
  Get_Deformation_Gradient(GP,Elem,F);

  /* Get B */
  for(int i = 0; i<Elem->NumberDOF ; i++){
    for(int j = 0; j<Elem->NumberDOF; j++){
      B[i][j] = F[i][j] * F[j][i];
      /* B    =    F    *  F^{T}  */
    }
  }
  
  /* Free memory */
  free(F);
  
  return B;
}


/* double ** Get_Stiffness_Matrix(double ** D,GaussPoint GP,Element Elem){ */

/*   double ** F = (double **)Allocate_Matrix(2,2,sizeof(double)); */
/*   double ** F_m1 = (double **)Allocate_Matrix(2,2,sizeof(double)); */

/*   for(int i = 0 ; i<Element.NumberGP ; i++){/\* Iterate over the Gauss Points *\/ */

/*     F = Get_Deformation_Gradient(GP,Elem); /\* Deformation gradient *\/ */
/*     F_m1 = Get_Inverse(F,2); /\* Get the inverse of the deformation gradient *\/ */
    
/*     for(int j = 0 ; j<Element.NumberNodes ; j++){/\* Iterate over the nodes in the Element *\/      */
/*       for(int k = 0 ; k<Element.NumberDOF ; k++){/\* Iterate over the degree of freedom *\/ */

	
	
/*       }/\* GP loop *\/ */
/*     }/\* Nodes loop *\/  */
/*   }/\* DOF loop *\/ */
  
/*   return K; */
/* } */
