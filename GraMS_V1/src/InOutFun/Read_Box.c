#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "../GRAMS/grams.h"

#define MAXVAL(A,B) ((A)>(B) ? (A) : (B))
#define MINVAL(A,B) ((A)<(B) ? (A) : (B))

/***************************************************************************/

Mesh DefineBackgroundMesh(char * GramsFile)
/*
  GramsBox (GID=FEM_Mesh.msh) {
  bottom = Boundary {
  BcDirichlet V 0
  }
  }
*/
{
  /* Asign mesh to an auxiliar variable */
  Mesh BackgroundMesh;
  int CountMesh = 0;

  /* Simulation file */
  FILE * Sim_dat;

  /* Special variables for line-reading */
  char line[MAXC] = {0}; /* Variable for reading the lines in the files */
  char * kwords[MAXW] = {NULL}; /* Variable to store the parser of a line */
  int nkwords; /* Number of element in the line , just for check */

  /* Mesh name */
  int Aux_Mesh_id;
  char * Parse_Mesh_id[MAXW] = {NULL};

  /* Auxiliar variable for status */
  char * STATUS_LINE;

  /* Boundary */
  char Line_Boundary[MAXC] = {0};
  char * Parse_Boundary[MAXW] = {NULL};
  int Aux_Boundary;

  /* Boundary conditions */
  char Line_BCC[MAXC] = {0};
  char * Parse_BCC[MAXW] = {NULL};
  int Aux_BCC;

  /* Initial message */  
  puts("*************************************************");
  printf(" \t %s : \n\t %s \n",
	 "* Begin of define calculus mesh in file",
	 GramsFile);
  
  /* Open and check file */
  Sim_dat = fopen(GramsFile,"r");  
  if (Sim_dat==NULL){
    printf("%s : \n\t %s %s",
	   "Error in DefineBackgroundMesh()",
	   "Incorrect lecture of",
	   GramsFile);
    exit(0);
  }

  /* Read the file line by line */
  while( fgets(line, sizeof line, Sim_dat) != NULL ){

    /* Read the line with the space as separators */
    nkwords = parse (kwords, line," \n\t");
    if (nkwords < 0){
      printf("%s : %s \n",
	     "Error in DefineBackgroundMesh()",
	     "Parser failed");
      exit(0);
    }

    /* Find GramsBox keyword */
    if (strcmp(kwords[0],"GramsBox") == 0 ){

      /* Count the number of mesh */
      ++CountMesh;

      /* Read the meshfile -> (GID=FEM_Mesh.msh) */
      Aux_Mesh_id = parse (Parse_Mesh_id, kwords[1],"(=)");
      if(Aux_Mesh_id != 2){
	printf("%s : %s \n",
	       "Error in DefineBackgroundMesh()",
	       "Use this format -> (GID=FEM_Mesh.msh) !!!");
	exit(0);
      }

      /* If the mesh has been generated by GID */
      if(strcmp(Parse_Mesh_id[0],"GID") == 0){
	BackgroundMesh = ReadGidMesh(Parse_Mesh_id[1]);
      }
      else{
	printf("%s : %s \n",
	       "Error in DefineBackgroundMesh()",
	       "Mesh format not suported !!!");	
	exit(0);	
      }

      /* Searching neighbours elements for each node */
      GetNodalConnectivity(BackgroundMesh);
      
      /* Define GPs connectivity of each element */
      BackgroundMesh.GPsElements =
	(ChainPtr *)malloc(BackgroundMesh.NumElemMesh*sizeof(ChainPtr));
      if(BackgroundMesh.GPsElements == NULL){
	printf("%s : %s \n",
	       "DefineBackgroundMesh()",
	       "Memory error for GPsElements");
	exit(0);
      }
      for(int i = 0 ; i<BackgroundMesh.NumElemMesh ; i++){
	BackgroundMesh.GPsElements[i] = NULL;
      }

      /* Set the minimum mesh size */
      BackgroundMesh.DeltaX = GetMinElementSize(BackgroundMesh);

      /* Quadrilateral elements */
      if(strcmp(BackgroundMesh.TypeElem,"Quadrilateral") == 0){ 
	BackgroundMesh.Bounds =  GetBoundaryBox(BackgroundMesh);
      }

      /* Check if we have the curly -> { */
      if(strcmp(kwords[2],"{") == 0){
	/* Initial line */
	STATUS_LINE = fgets(Line_Boundary,
			    sizeof(Line_Boundary),
			    Sim_dat);
	if(STATUS_LINE == NULL){
	  printf("%s : %s \n",
		 "Error in DefineBackgroundMesh()",
		 "Unspected EOF !!!");
	  exit(0);	
	}
	Aux_Boundary = parse(Parse_Boundary,Line_Boundary," =\t\n");
	while(STATUS_LINE != NULL){

	  if(Aux_Boundary != 2){
	    printf("%s : %s \n",
		   "Error in DefineBackgroundMesh()",
		   "Use this format -> bottom = Boundary !!!");
	    exit(0);
	  }

	  if( (strcmp(Parse_Boundary[0],"bottom") == 0 ) &&
	      (strcmp(Parse_Boundary[1],"Boundary") == 0 ) &&
	      (strcmp(Parse_Boundary[2],"{") == 0 ) ){

	    /* Initial line */
	    STATUS_LINE = fgets(Line_BCC,
				sizeof(Line_BCC),
				Sim_dat);
	    if(STATUS_LINE == NULL){
	      printf("%s : %s \n",
		     "Error in DefineBackgroundMesh()",
		     "Unspected EOF !!!");
	      exit(0);	
	    }
	    Aux_BCC = parse(Parse_BCC,Line_BCC," =\t\n");
	    while(STATUS_LINE != NULL){

	      /*  V 0 */
	      if(strcmp(Parse_BCC[0],"BcDirichlet") == 0){
		break;
	      }
	      
	      /* Read next line and check */
	      STATUS_LINE = fgets(Line_Boundary,
				  sizeof(Line_Boundary),
				  Sim_dat);
	      Aux_BCC = parse(Parse_BCC,Line_BCC," =\t\n");
	      if(strcmp(Parse_BCC[0],"}") == 0){
		break;
	      }
	    }
	    if(STATUS_LINE == NULL){
	      printf("%s : %s \n",
		     "Error in DefineBackgroundMesh()",
		     "you forget to put a } !!!");
	      exit(0);	  
	    }
	    if(strcmp(Parse_BCC[0],"}") == 0){
	      break;
	    }
	    
	  }
	  else if( (strcmp(Parse_Boundary[0],"top") == 0 ) &&
		   (strcmp(Parse_Boundary[1],"Boundary") == 0 ) &&
		   (strcmp(Parse_Boundary[2],"{") == 0 ) ){

	    
	    /* Initial line */
	    STATUS_LINE = fgets(Line_BCC,
				sizeof(Line_BCC),
				Sim_dat);
	    if(STATUS_LINE == NULL){
	      printf("%s : %s \n",
		     "Error in DefineBackgroundMesh()",
		     "Unspected EOF !!!");
	      exit(0);	
	    }
	    Aux_BCC = parse(Parse_BCC,Line_BCC," =\t\n");
	    while(STATUS_LINE != NULL){
 
	      /* Read next line and check */
	      STATUS_LINE = fgets(Line_Boundary,
				  sizeof(Line_Boundary),
				  Sim_dat);
	      Aux_BCC = parse(Parse_BCC,Line_BCC," =\t\n");
	      if(strcmp(Parse_BCC[0],"}") == 0){
		break;
	      }
	    }
	    if(STATUS_LINE == NULL){
	      printf("%s : %s \n",
		     "Error in DefineBackgroundMesh()",
		     "you forget to put a } !!!");
	      exit(0);	  
	    }
	    if(strcmp(Parse_BCC[0],"}") == 0){
	      break;
	    }
	    
	  }
	  else if( (strcmp(Parse_Boundary[0],"left") == 0 ) &&
		   (strcmp(Parse_Boundary[1],"Boundary") == 0 ) &&
		   (strcmp(Parse_Boundary[2],"{") == 0 ) ){

	    
	    /* Initial line */
	    STATUS_LINE = fgets(Line_BCC,
				sizeof(Line_BCC),
				Sim_dat);
	    if(STATUS_LINE == NULL){
	      printf("%s : %s \n",
		     "Error in DefineBackgroundMesh()",
		     "Unspected EOF !!!");
	      exit(0);	
	    }
	    Aux_BCC = parse(Parse_BCC,Line_BCC," =\t\n");
	    while(STATUS_LINE != NULL){
	      
	      /* Read next line and check */
	      STATUS_LINE = fgets(Line_Boundary,
				  sizeof(Line_Boundary),
				  Sim_dat);
	      Aux_BCC = parse(Parse_BCC,Line_BCC," =\t\n");
	      if(strcmp(Parse_BCC[0],"}") == 0){
		break;
	      }
	    }
	    if(STATUS_LINE == NULL){
	      printf("%s : %s \n",
		     "Error in DefineBackgroundMesh()",
		     "you forget to put a } !!!");
	      exit(0);	  
	    }
	    if(strcmp(Parse_BCC[0],"}") == 0){
	      break;
	    }
	    
	  }
	  else if( (strcmp(Parse_Boundary[0],"right") == 0 ) &&
		   (strcmp(Parse_Boundary[1],"Boundary") == 0 ) &&
		   (strcmp(Parse_Boundary[2],"{") == 0 ) ){

	    
	    /* Initial line */
	    STATUS_LINE = fgets(Line_BCC,
				sizeof(Line_BCC),
				Sim_dat);
	    if(STATUS_LINE == NULL){
	      printf("%s : %s \n",
		     "Error in DefineBackgroundMesh()",
		     "Unspected EOF !!!");
	      exit(0);	
	    }
	    Aux_BCC = parse(Parse_BCC,Line_BCC," =\t\n");
	    while(STATUS_LINE != NULL){
	      
	      /* Read next line and check */
	      STATUS_LINE = fgets(Line_Boundary,
				  sizeof(Line_Boundary),
				  Sim_dat);
	      Aux_BCC = parse(Parse_BCC,Line_BCC," =\t\n");
	      if(strcmp(Parse_BCC[0],"}") == 0){
		break;
	      }
	    }
	    if(STATUS_LINE == NULL){
	      printf("%s : %s \n",
		     "Error in DefineBackgroundMesh()",
		     "you forget to put a } !!!");
	      exit(0);	  
	    }
	    if(strcmp(Parse_BCC[0],"}") == 0){
	      break;
	    }
	    
	  }
	  else{
	    printf("%s : %s -> %s \n",
		   "Error in DefineBackgroundMesh()",
		   "Undefined boundary",Parse_Boundary[0]);
	    exit(0);
	  }
	  /* Read next line and check */
	  STATUS_LINE = fgets(Line_Boundary,
			      sizeof(Line_Boundary),
			      Sim_dat);
	  Aux_Boundary = parse(Parse_Boundary,Line_Boundary," =\t\n");
	  if(strcmp(Parse_Boundary[0],"}") == 0){
	    break;
	  }
	}
	if(STATUS_LINE == NULL){
	  printf("%s : %s \n",
		 "Error in DefineBackgroundMesh()",
		 "you forget to put a } !!!");
	  exit(0);	  
	}

	if(strcmp(Parse_Boundary[0],"}") == 0){
	  break;
	}
      }
      

    }
  }

  /* Check the number of materials */
  if(CountMesh != 1){
    printf("%s : %s %i %s %i %s \n",
	   "Error in DefineBackgroundMesh()",
	   "Spected",1, "mesh, but",
	   CountMesh,"where defined !!!");
    exit(0);
  }

  
  /* Close .gdf file */
  /* Final message */
  printf("\t * End of read data file !!! \n");
  fclose(Sim_dat);

  return BackgroundMesh;
}

/***************************************************************************/

Boundaries Set_FEM_BCC(char * Name_File, Mesh FEM_Mesh)
/*
  Read the boundary conditions file :
  Inputs
  - Name_file : Name of the file
  BCC LABEL=TOP FIELD=V DIR={0,1} CURVE={Curve.txt}
  BCC LABEL=BOTTOM FIELD=V DIR={0,1} CURVE={Curve.txt}
  BCC LABEL=RIGHT FIELD=V DIR={1,0} CURVE={Curve.txt}
  BCC LABEL=LEFT FIELD=V DIR={1,0} CURVE={Curve.txt}
  
  Note : Only read those lines with a BCC in the init 
*/
{

  /* Auxiliar variable with the number of nodes in a element */
  int NumNodesElem;
  
  /* Define output */
  Boundaries FEM_BCC;
  
  /* Pointer to the FEM boundary conditions file */
  FILE * File_BCC;

  /* Number of boundary conditions */
  int BCC_NUM = 0;
  
  /* Auxiliar structure with the load curve */
  Curve Curve_BCC;
  
  /* Auxiliar variable for reading the lines in the files */
  char line[MAXC] = {0};
  
  /* Number of element in the line , just for check */
  int nkwords,nparam;
  char * kwords[MAXW] = {NULL};
  char * param[MAXW] = {NULL};

  /* Read the field */
  char * FIELD;

  /* Auxiliar table to store the boundaries */
  int * NodesBound_aux;
  int * CounterNodesBound;
  int NumNodesBound;

  /* Count the number of elements that share this node */
  ChainPtr Elem_Conn; /* Loop over the connectivity chain */
  int Repeat_Nod; /* Counter */
  /* Variables that fills the boundaries nodes */
  int aux_RIGHT = 0; 
  int aux_TOP = 0;
  int aux_LEFT = 0;
  int aux_BOTTOM = 0;
  /* Set to zero X and Y min and max values of the mesh */
  double MAX_X, MAX_Y, MIN_X, MIN_Y;
  
  /* Boundaries labels */
  char * BoundLabels [4] = {"BOTTOM", "RIGHT", "TOP", "LEFT"};
  /* Index of the boundary to apply the BCC from (0 -> N_bounds -1) */
  int IndexBoundary = -999;

  /* Kind of domain */
  strcpy(FEM_BCC.Info,"SQUARE");      
  
  /* Asign the number of boundaries for a square domain */
  FEM_BCC.NumBounds = 4;

  /* Generate boundaries for the domain */
  FEM_BCC.BCC_i = (Load *)Allocate_Array(FEM_BCC.NumBounds,sizeof(Load));

  /* Fill some parameters */
  for(int i = 0 ; i<FEM_BCC.NumBounds  ; i++){
    /* Set to zero the number of nodes in the boundary of the mesh */
    FEM_BCC.BCC_i[i].NumNodes = 0;
    /* Set the labels for a square domain */
    strcpy(FEM_BCC.BCC_i[i].Info,BoundLabels[i]);
  }
 
  /*
    - BCC LABEL=TOP FIELD#V DIR={0,1} CURVE#{curve.txt}
  */
    
  /* Find the nodes in the boundary */
  switch(NumberDimensions){
    
  case 1: /******************** 1D mesh ********************/
    /*
     *-----*
     0     1
     */
    /* In a 1D mesh we only have two nodes in the boundary */
    FEM_BCC.BCC_i[0].NumNodes = 1;
    FEM_BCC.BCC_i[1].NumNodes = 1;
    /* Allocate the size of the array with the nodes */
    FEM_BCC.BCC_i[0].Nodes = (int *)Allocate_ArrayZ(1,sizeof(int));
    FEM_BCC.BCC_i[1].Nodes = (int *)Allocate_ArrayZ(1,sizeof(int));
    /* Set the nodes of the boundaries */
    FEM_BCC.BCC_i[0].Nodes[0] = 0;
    FEM_BCC.BCC_i[0].Nodes[0] = 1-FEM_Mesh.NumNodesMesh;
    
    break; /******************** 2D mesh ********************/
    
  case 2: /******************** 2D mesh ********************/
    /*  2
     *-----*
     |     |
     |3    |1
     |     | 
     *-----*
        0
    */

    /* FIX THIS ---> TEMPORARY */
    NumNodesElem = FEM_Mesh.NumNodesElem[0];
    
    if(NumNodesElem == 4){ /* Quadrilateral elements */
      /* 0º Allocate an array of zeros to assign a 1 to those nodes in the boundary */
      NodesBound_aux = (int *)Allocate_ArrayZ(FEM_Mesh.NumNodesMesh,sizeof(int));
      CounterNodesBound = (int *)Allocate_ArrayZ(4,sizeof(int));
      /* 1º Set to zero the number of nodes in the boundary */
      NumNodesBound = 0;
      /* 2º Iterate over the nodes to fin the nodes in the boundary */

      /* 3º Get the max values of the boundary */
      MAX_X = FEM_Mesh.Coordinates.nM[0][0];
      MAX_Y = FEM_Mesh.Coordinates.nM[0][1];
      MIN_X = FEM_Mesh.Coordinates.nM[0][0];
      MIN_Y = FEM_Mesh.Coordinates.nM[0][1];
      
      for(int i = 0 ; i<FEM_Mesh.NumNodesMesh ; i++){

  	/* 3º Get the max values of the boundary */
  	MAX_X = MAXVAL(MAX_X,FEM_Mesh.Coordinates.nM[i][0]);
  	MAX_Y = MAXVAL(MAX_Y,FEM_Mesh.Coordinates.nM[i][1]);
  	MIN_X = MINVAL(MIN_X,FEM_Mesh.Coordinates.nM[i][0]);
  	MIN_Y = MINVAL(MIN_Y,FEM_Mesh.Coordinates.nM[i][1]);
	
  	/* 4º Set the counter to zero */
  	Repeat_Nod = 0;
	
  	/* 5º Loop over the connectivity mesh */
	for(int j = 0 ; j<FEM_Mesh.NumElemMesh ; j++){
	  Elem_Conn = FEM_Mesh.Connectivity[j];
	  while(Elem_Conn != NULL){
	    if((Elem_Conn->I) == i){
	      Repeat_Nod++;
	    }
	    Elem_Conn = Elem_Conn->next;
	  }
	}
	
  	/* 6º Add this element to the boundary */
  	if (Repeat_Nod < 4){
  	  NodesBound_aux[i] = 1;
  	  NumNodesBound++;
  	}
      }
      
      /* 7º Count the number of nodes in each boundarie */
      for(int i = 0 ; i<FEM_Mesh.NumNodesMesh ; i++){
  	if(NodesBound_aux[i] == 1){

	  if(FEM_Mesh.Coordinates.nM[i][1] == MIN_Y){
	    /* Count number of nodes in the bottom */
	    CounterNodesBound[0]++;
  	  }
  	  if(FEM_Mesh.Coordinates.nM[i][0] == MAX_X){
	    /* Count number of nodes in the right */
	    CounterNodesBound[1]++;
  	  }
  	  if(FEM_Mesh.Coordinates.nM[i][1] == MAX_Y){
	    /* Count the number of nodes in the top */
	    CounterNodesBound[2]++;
  	  }
  	  if(FEM_Mesh.Coordinates.nM[i][0] == MIN_X){
	    /* Count the number of nodes in the left */
	    CounterNodesBound[3]++;
  	  }
	    
  	}
      }
      
      /* Allocate the arrays with the boundary nodes */
      for(int i = 0 ; i<FEM_BCC.NumBounds ; i++){
	FEM_BCC.BCC_i[i].NumNodes = CounterNodesBound[i];
	FEM_BCC.BCC_i[i].Nodes =
	  (int *)Allocate_ArrayZ(CounterNodesBound[i],sizeof(int));
      }

      /* Free data */
      free(CounterNodesBound);
      

      /* Fill the arrays  */
      for(int i = 0 ; i<FEM_Mesh.NumNodesMesh ; i++){
  	if(NodesBound_aux[i] == 1){

	  if(FEM_Mesh.Coordinates.nM[i][1] == MIN_Y){
  	    FEM_BCC.BCC_i[0].Nodes[aux_BOTTOM] = i;
  	    aux_BOTTOM++;
  	  }
  	  if(FEM_Mesh.Coordinates.nM[i][0] == MAX_X){
  	    FEM_BCC.BCC_i[1].Nodes[aux_RIGHT] = i;
  	    aux_RIGHT++;
  	  }
  	  if(FEM_Mesh.Coordinates.nM[i][1] == MAX_Y){
  	    FEM_BCC.BCC_i[2].Nodes[aux_TOP] = i;
  	    aux_TOP++;
  	  }
  	  if(FEM_Mesh.Coordinates.nM[i][0] == MIN_X){
  	    FEM_BCC.BCC_i[3].Nodes[aux_LEFT] = i;
  	    aux_LEFT++;
  	  }

	    
  	}
      }

      
    } /* Quadrilateral elements */
    if(NumNodesElem == 3){ /* Triangular elements */
      printf("%s : %s \n",
	     "Error in Set_FEM_BCC()",
	     "Boundary nodes localization for T3 not implemented yet !");
    } /* Triangular elements */
    
    /* Free data */ 
    free(NodesBound_aux);

    break; /******************** 2D mesh ********************/
    
  case 3: /******************** 3D mesh ********************/
    puts("*************************************************");
    printf("%s : %s \n",
	   "Error in Set_FEM_BCC()",
	   "3D cases not implemented yet !");
    puts("*************************************************");
    exit(0);
    break; /******************** 2D mesh ********************/
    
  default :
    puts("*************************************************");
    printf("%s : %s \n",
	   "Error in Set_FEM_BCC()",
	   "Wrong number of dimensions !");
    puts("*************************************************");
    exit(0);
  }


  /* Initial message */  
  printf(" \t %s : \n\t %s \n",
	 "-> Begin of read boundary conditions in",
	 Name_File);
  
  /* Open and check .bcc file */
  File_BCC = fopen(Name_File,"r");  
  if (File_BCC==NULL){
    puts("Error during the lecture of .bcc file");
    exit(0);
  }

  /* Read the file line by line */
  while( fgets(line, sizeof line, File_BCC) != NULL ){

    /* Read the line with the space as separators */
    nkwords = parse (kwords, line," \n\t");

    /* When the parser find the keyword BCC_NUM : start reading BCC */
    if(strcmp(kwords[0],"BCC_NUM") == 0 ){

      BCC_NUM = atoi(kwords[1]);

      for(int i = 0 ; i<BCC_NUM ; i++){

	/* Read as line as BCC */
	fgets(line, sizeof line, File_BCC);
	/* Read the line with the space as separators */
	nkwords = parse (kwords, line," \n\t");

	/* Set BCC in those node in the left of the domain */
	if( (nkwords == 5) && ( strcmp(kwords[0],"BCC") == 0)){

	  /* Read the label to impose the boundary condition */
	  nparam = parse (param,kwords[1],"=\n");
	  if(strcmp(param[0],"LABEL") == 0){
	    for(int j = 0; j<FEM_BCC.NumBounds ; j++){
	      if(strcmp(param[1],BoundLabels[j]) == 0)
		IndexBoundary = j;
	    }
	  }
	  else{
	    printf("%s : %s \n",
		   "Error in Set_FEM_BCC()",
		   "Wrong format !!!");
	    exit(0);
	  }

	
	  /* Read the field to impose the boundary condition */
	  nparam = parse (param,kwords[2],"=\n");
	  if( (strcmp(param[0],"FIELD") == 0 ) && (nparam == 2) ){
	    strcpy(FEM_BCC.BCC_i[IndexBoundary].Info,param[1]);
	  }
	  else{
	    printf("%s : %s \n",
		   "Error in Set_FEM_BCC()",
		   "Wrong format !!!");
	    exit(0);
	  }

	  /* Read the dirrection to impose the boundary condition */
	  nparam = parse (param,kwords[3],"={,}\n");
	  if( (strcmp(param[0],"DIR") == 0 ) && (nparam >= 2) ){
	    /* Number of dimensions of the BCC */
	    FEM_BCC.BCC_i[IndexBoundary].Dim = nparam - 1;
	    /* Direction of the BCC */
	    FEM_BCC.BCC_i[IndexBoundary].Dir =
	      (int *)Allocate_Array(FEM_BCC.BCC_i[IndexBoundary].Dim,sizeof(int));
	    /* Fill the direction of the BCC */
	    for(int j = 0 ; j<FEM_BCC.BCC_i[IndexBoundary].Dim ; j++){
	      FEM_BCC.BCC_i[IndexBoundary].Dir[j] = atoi(param[j+1]);
	    }	    
	  }
	  else{
	    printf("%s : %s \n",
		   "Error in Set_FEM_BCC()",
		   "Wrong format !!!");
	    exit(0);
	  }

	  /* Read the curve to impose the boundary condition */
	  nparam = parse (param,kwords[4],"={,}\n");
	  if( (strcmp(param[0],"CURVE") == 0) || (nparam >= 2) ){

	    /* Alocate the table of curves */
	    FEM_BCC.BCC_i[IndexBoundary].Value =
	      (Curve *)Allocate_Array(FEM_BCC.BCC_i[IndexBoundary].Dim,
				      sizeof(Curve));
	    /* Fill the curve table */
	    for(int j = 0 ; j<FEM_BCC.BCC_i[IndexBoundary].Dim ; j++){
	      if(strcmp(param[j+1],"NULL") != 0)
		FEM_BCC.BCC_i[IndexBoundary].Value[j] = ReadCurve(param[j+1]);
	    }    
	  }
	  else{
	    printf("%s : %s \n",
		   "Error in Set_FEM_BCC()",
		   "Wrong format !!!");
	    exit(0);
	  }
      
	} /* End of read BC */
	else{
	    printf("%s : %s \n",
		   "Error in Set_FEM_BCC()",
		   "Wrong format !!!");
	    exit(0);
	}
	
      }
      
    } /* End of if(strcmp(kwords[0],"BCC_NUM") == 0 ) */
    
  }  /* End of while */
  printf("\t %s \n",
       "-> End of read boundary conditions file !!!");
  fclose(File_BCC);

  return FEM_BCC;
  
} /* BoundayConditions ReadBCC(char * Name_File) */

/***************************************************************************/
